# Примитивные и ссылочные типы в Java

## Примитивные типы

Рассмотрим таблицу, в которой перечислены все примитивные типы в Java:

| Тип       | Размер (байт) | Класс-обёртка |
|-----------|:-------------:|---------------|
| `void`    |       0       | `Void`        |
| `boolean` |     1 бит     | `Boolean`     |
| `char`    |       2       | `Character`   |
| `byte`    |       1       | `Byte`        |
| `short`   |       2       | `Short`       |
| `int`     |       4       | `Integer`     |
| `long`    |       8       | `Long`        |
| `float`    |       4       | `Float`       |
| `double`  |       8       | `Double`      |

Особенности:

* Как `boolean` занимает 1 бит? Идея в том, что 8 разных переменных типа `boolean` могут храниться в одной 8-битной ячейке памяти, тем самым занимая по 1 биту каждая. Стоит отметить, что это зависит от реализации JVM. Есть JVM, в которых `boolean` занимает столько же, сколько и `int`. В спецификации языка Java это единственный примитивный тип, для которого не определён строгий размер.

Примитивные типы можно разделить на целочисленные, нецелочисленные, символьный тип `char`, логический тип `boolean` и пустой тип `void`.

> Примитивные типы передаются по значению. Что это значит?
>
> Это значит, что выражение `x = y`, где `x` и `y` имеют какой-нибудь примитивный тип (для определённости пусть это будет `int`) приведёт к тому, что значение переменной `y` будет скопировано в переменную `x`.
>
> Если после этого, например, вызвать оператор инкремента у переменной `x`: `x++`, то значение `y` останется прежним, так как оно было скопировано.
>
> Пример:
> ```java
> int x = 4;
> int y = 2;
> x = y;
> x++;
> // x == 3, y == 2
> ```

## Ссылочные типы

В противопоставление примитивным типам в Java также имеются ссылочные типы. Все остальные типы, кроме перечисленных выше являются ссылочными.

> Часто говорят, что "ссылка" сама по себе является особым примитивным типом. 
>
>Действительно, если рассматривать любую переменную ссылочного типа как переменную, хранящую некий адрес в памяти, с которым особенным образом умеет обращаться Java, то такая переменная – которая просто хранит целое число – будет являться переменной примтивного типа.

Передача значения по ссылке позволяет двум переменным указывать на один и тот же объект. Это значит, что изменение этого объекта в одной переменной приведёт к его изменению в другой переменной.

Пример:
```java
Book book = new Book("The Gold-Hatted Gatsby");
Book favouriteBook = book;

book.setTitle("The Great Gatsby");
// book.title == "The Great Gatsby"
// favouriteBook.title == "The Great Gatsby"
```

Специальное значение, которое обозначает отсутствие текущего значения у переменной ссылочного типа, называется `null`. Его можно присвоить любой переменной, имеющей ссылочный тип.

Любая ссылочная переменная по умолчанию инициализирована значением `null`. То есть, в результате исполнения следующего кода:

```java
String x;
```

значение переменной `x` будет `null`.

### `java.lang.Object` 

Любая переменная ссылочного типа на вершине иерархии наследования имеет класс `Object`.

> `null` не является объектом ссылочного типа, и как следствие, не наследуется от `Object`. Строго говоря, `null` вообще не является объектом.

Побочным эффектом (предусмотренным дизайном языка) от того, что все объекты наследуются от `Object` является то, что у всех объектов можно вызвать (или переопределить) методы, определённые в `Object`.

Неполный список этих методов:
* `String toString()` – позволяет привести любой объект к строке. По умолчанию реализация этого метода возвращает имя класса и некоторое число, о котором можно думать, как об адресе объекта в памяти. У некоторых классов стандартной библиотеки (например, `ArrayList` или `Map.Entry`) этот метод переопределён для того, чтобы возвращать более информативное строковое представление объекта
* `int hashCode()` – позволяет получить хеш-код объекта. Он используется, например, в `HashMap` для того, чтобы определить, в какую ячейку хеш-таблицы можно положить данный объект
* `boolean equals(Object object)` – позволяет проверить равенство двух объектов

> Контракт между `equals()` и `hashCode()`
>
> Очень важно следить за тем, чтобы при переопределении метода `equals()` в своих объектах, также соответствующим образом переопределять метод `hashCode()`. Но почему? 
>
> На самом деле, ожидается строгое выполнение следующего инварианта: *если метод `a.equals(b)` вернул `true`, то хеш-коды `a.hashCode()` и `b.hashCode()` должны совпадать*.
>
> Реализации некоторых алгоритмов и структур данных (например, `HashMap`) полагаются на выполнение этого инварианта. В противном случае не гарантируется их корректная работа.

#### В чём разница между `a.equals(b)` и `a == b`?

На первый взгляд обе этих конструкции должны выполнять одно и то же: проверку на равенство. Однако, между ними есть большая разница.

`a == b` проверяет равенство ссылок. То есть, указывают ли обе эти переменные на один и тот же объект в памяти. Только в этом случае результат этого выражения равняется `true`, во всех остальных случаях – `false`.

Пример:

```java
Book firstBook = new Book("1984");
Book secondBook = new Book("1984");

firstBook == secondBook // false


Book book = firstBook;

firstBook == book; // true
```

`a.equals(b)`, в свою очередь, проверяет равенство объектов по содержимому. Так, например, этот метод определён для классов стандартной библиотеки, что позволяет, например, проверить равенство двух объектов класса `HashMap` вызовом одного метода!

Также стоит помнить, что дефолтная реализация метода `equals()` в `Object` выглядит следующим образом:

```java
boolean equals(Object other) {
    return this == other;
}
```

То есть, по умолчанию это просто заменяется на проверку равенства ссылок. Об этом важно помнить, создавая собственные классы, так как при наличии полей наверняка равенства ссылок будет недостаточно.

## `boolean`

`boolean` является типом данных для логических значений в Java. Переменные такого типа могут принимать значения `true` или `false`.

Например, все операторы сравнения возвращают значение логического типа в результате их применения.

> Всего в Java есть шесть операторов сравнения: `>`, `>=`, `<`, `<=`, `==`, `!=`

Есть одна особенность, которая сильно отличает Java от, например, C++ и подобных языков, в которых есть эта возможность. В Java нет неявного приведения к логическому типу. То есть, для того, чтобы проверить, равняется ли нулю целочисленная переменная, недостаточно поместить её в условие оператора `if`: обязательно вызвать операцию явного сравнения с нулём.

| Нельзя                          |                   Можно                |
|---------------------------------|----------------------------------------|
| ```java int x = 10; if (x) {}``` | ```java int x = 10; if (x != 0) {} ``` |

Помимо операторов сравнения, в Java также есть ещё несколько операторов, возвращающих `boolean`. Это так называемые логические операции.

| Операция             | Оператор |
|----------------------|:--------:|
| Логическое "и"       |   `&&`   |
| Логическое "или"     | `||`     |
| Исключающее или      | `^`      |
| Логическое отрицание | `!`      |

Для первых трёх операторов существует также их разновидность, совмещённая с оператором присваивания, а именно: `&=`, `|=` и `^=`. Они работают (на примере логического "и") по следующей схеме:

```java
boolean a, b;

a = a && b;
// Снизу – сокращённая запись выражения сверху
a &= b;
```

### Вычисление по сокращённой схеме

Существует два варианта операторов логического "и" и "или". Для "и" это `&` и `&&`, а для "или" – `|` и `||`. В чём между ними разница?

Как известно из алгебры логики, выражение, состоящее из цепочки подвыражений, связанных логическим "и", ложно тогда, когда хотя бы одно из подвыражений ложно. В Java тоже есть такая возможность: при использовании операторов вычисления по сокращённой схеме (они состоят из двух символов: `&&` и `||`) в качестве результата выражения сразу вернётся `false` как только одно из подвыражений в цепочке, связанной оператором `&&`, будет вычислено как ложное.

С этим нужно обходиться осторожно. Так, например, при соответствующих условиях не будут вычислены выражения даже имеющие побочные эффекты. Например, если в выражении `foo() && bar() && baz()` функция `foo()` вернёт `false`, а остальные функции при вызове должны были напечатать что-то на экран, на экран не будет выведено ничего.

### `java.lang.Boolean`

У класса-обёртки `Boolean` есть несколько удобных функций.

Например, есть метод `boolean parseBoolean(String)`, который по строке определяет, какой логический литерал кодирует эта строка. Вообще говоря, этот метод возвращает `true` исключительно в том случае, если передпнная на вход строка в точности равна `"true"`.

Также, чтобы избежать лишних выделений памяти, когда в этом нет необходимости, класс `Boolean` предоставляет две статические константы: `Boolean.TRUE` и `Boolean.FALSE`. Так, например, большинство IDE будет выдавать предупреждение, если напрямую вызвать `new Boolean(true)`, потому что можно было бы использовать статическую константу.

## `char`

Представителем символьного типа в языке Java является тип `char`. Переменные такого типа могут хранить символы в кодировке Unicode.

Стоит отметить, что выражение типа `char` можно неявно привести к любому (кроме `byte`, так как у него меньше размер) целочисленному типу.

### Как можно задавать значения типа `char`?

Во-первых, существуют символные литералы. Это символ Unicode, заключённый в одинарные кавычки: `'F'`.

Помимо этого символ можно задавать с помощью его шестнадцатиричного кода (полезно, например, для непечатаемых символов – управляющих последовательностей из начала таблицы ASCII или для специальных символов, с помощью которых можно настроить задать текста в терминале): `'\u263a'`.

Последним способом является задание некоторых спецпоследовательностей, распознаваемых языком. Перечислим их в таблице ниже:

| Последовательность |                      Описание                      |
|--------------------|:--------------------------------------------------:|
| `\t`               |                  Символ табуляции                  |
| `\b`               | Символ backspace: удаление одного символа в строке |
| `\n`               | Символ перехода на новую строку                    |
| `\r`               | Символ возврата каретки                            |
| `\f`               | Символ "смены страницы" (form feed)                |
| `\'`               | Символ одинарной кавычки                           |
| `\"`               | Символ двойной кавычки                             |
| `\\`               | Символ одной обратной косой черты `\`              |

### `java.lang.Character`

У класса `Character` есть несколько статических методов (весьма полезных, например, при посимвольном парсинге данных), которые определяют, к какому классу принадлежит переданный аргументом символ. К таким методам относятся:

* `boolean isLowerCase(char x)`
* `boolean isUpperCase(char x)`
* `boolean isDigit(char x)`
* `boolean isWhiteSpace(char x)`
* `boolean isLetter(char x)`

Помимо этого также есть методы для конвертации символа в верхний и нижний регистр:

* `char toUpperCase(char x)`
* `char toLowerCase(char x)`

Ещё можно отметить наличие методов `int digit(char ch, int radix)` и обратного к нему `char forDigit(int digit, int radix)`. Они позволяют получить число, которому соответствует символ в указанной системе счисления и наоборот: по числу и системе счисления позволяет вернуть символ, которым это число будет кодироваться.

Это далеко не полный список методов этого класса, всего у него в публичном интерфейсе порядка 90 методов и много разных статических констант.

## Целочисленные типы

Серьёзным отличием от C++ является то, что размер всех целочисленных типов зафиксирован стандартом и не зависит от конкретной реализации JVM. Конкретные размеры типов данных приведены в таблице в начале главы.

### Как можно задавать значения целочисленных типов?

Для этого существует несколько различных вариантов. Самый простой – задать число в его десятичном представлении. Однако, числовые литералы можно представлять и в других системах счисления!

Чтобы задать числовой литерал в восьмеричной системе счисления, необходимо в качестве первого символа указать `0` (например: `int x = 016` задаст число 14, записанное в восьмеричной системе счисления).

Чтобы задать в шестнадцатиричной системе счисления – нужно указать префикс `0x` (например: `int x = 0xf1` задаст число 241, записанное в шестнадцатиричной системе счисления).

Начиная с Java 7, появился ещё один вариант записи целочисленных литералов. Теперь число можно задать и в двоичной системе счисления, для чего указывается префикс `0b` (например: `int x = 0b110` задаст число 6, записанное в довичной системе счисления).

Помимо представления в разных системах счисления, существуют ещё некоторые способы записи целочисленных литералов. Так, для того, чтобы задать литерал типа `long`, необходимо добавить суффикс `L` к записи числа (в любой из перечисленных выше систем счисления). Так, например, можно уберечь себя от ошибки, когда по неосторожности присваивается литерал, имеющий тип `long` в переменную типа `int`.

> Начиная с Java 7, в записи числа допустимы нижние подчёркивания. Этим можно пользоваться, например, для визуальной группировки разрадов числа, что значительно упрощает его чтение человеком. Сравните, насколько быстро получится понять порядок следующих двух чисел: `long x = 1000000000;` и `long y = 1_000_000_000;`.

### Арифметические операции

Все целочисленные типы поддерживают стандартный набор арифметических операций: сложение, вычитание, умножение, деление и взятие остатка от деления. Для каждой из этих операций существует соответствующий арифметический оператор, а также оператор, совмещённый с присваиванием.

Помимо них переменные целочисленного типа данных поддерживают операцию (как префиксного, так и постфиксного) инкремента и декремента (`++` и `--`).

При делении **целого числа** на ноль, бросается исключение `ArithmeticException`. (Акцент на следующем: для чисел с плавающей точкой деление на ноль имеет другое поведение, которое не приводит к возникновению исключения)

Переполнение (в отличие от C++) не является неопределённым поведением. При переполнении просто отбрасываются старшие биты получившегося числа. Для сравнения в C++ такое поведение гарантируется для беззнаковых чисел, а для чисел со знаком оно не определено.

### Классы-обёртки

Из примечательного в классах-обёртках можно выделить наличие статических полей, содержащих минимальное и максимальное возможное значение соответствующего типа. Например, `java.lang.Integer.MAX_VALUE` и `java.lang.Integer.MIN_VALUE`.

Также в них есть методы для безопасной конвертации значений в числа с плавающей точкой (`double doubleValue()`), парсинга числа из строки (`int parseInteger(String s, int radix)`) и многие другие.

> **А что с беззнаковыми числами?**
>
> До Java 8 их просто не было. Совсем 🙂.
>
> С Java 8 был расширен интерфейс классов-обёрток над целочисленными типами: туда добавили операции, которые позволяют работать с содержимым класса как с беззнаковым целым числом. К числу таких методов, например, относится `int divideUnsigned(int a, int b)`, который интерпретирует числа `a` и `b` как беззнаковые целые, и вернёт резальтат деления `a` на `b`.


