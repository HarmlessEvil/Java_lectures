# Примитивные и ссылочные типы в Java

## Примитивные типы

Рассмотрим таблицу, в которой перечислены все примитивные типы в Java:

| Тип       | Размер (байт) | Класс-обёртка |
|-----------|:-------------:|---------------|
| `void`    |       0       | `Void`        |
| `boolean` |     1 бит     | `Boolean`     |
| `char`    |       2       | `Character`   |
| `byte`    |       1       | `Byte`        |
| `short`   |       2       | `Short`       |
| `int`     |       4       | `Integer`     |
| `long`    |       8       | `Long`        |
| `float`    |       4       | `Float`       |
| `double`  |       8       | `Double`      |

Особенности:

* Как `boolean` занимает 1 бит? Идея в том, что 8 разных переменных типа `boolean` могут храниться в одной 8-битной ячейке памяти, тем самым занимая по 1 биту каждая. Стоит отметить, что это зависит от реализации JVM. Есть JVM, в которых `boolean` занимает столько же, сколько и `int`. В спецификации языка Java это единственный примитивный тип, для которого не определён строгий размер.

Примитивные типы можно разделить на целочисленные, нецелочисленные, символьный тип `char`, логический тип `boolean` и пустой тип `void`.

> Примитивные типы передаются по значению. Что это значит?
>
> Это значит, что выражение `x = y`, где `x` и `y` имеют какой-нибудь примитивный тип (для определённости пусть это будет `int`) приведёт к тому, что значение переменной `y` будет скопировано в переменную `x`.
>
> Если после этого, например, вызвать оператор инкремента у переменной `x`: `x++`, то значение `y` останется прежним, так как оно было скопировано.
>
> Пример:
> ```java
> int x = 4;
> int y = 2;
> x = y;
> x++;
> // x == 3, y == 2
> ```

## Ссылочные типы

В противопоставление примитивным типам в Java также имеются ссылочные типы. Все остальные типы, кроме перечисленных выше являются ссылочными.

> Часто говорят, что "ссылка" сама по себе является особым примитивным типом. 
>
>Действительно, если рассматривать любую переменную ссылочного типа как переменную, хранящую некий адрес в памяти, с которым особенным образом умеет обращаться Java, то такая переменная – которая просто хранит целое число – будет являться переменной примтивного типа.

Передача значения по ссылке позволяет двум переменным указывать на один и тот же объект. Это значит, что изменение этого объекта в одной переменной приведёт к его изменению в другой переменной.

Пример:
```java
Book book = new Book("The Gold-Hatted Gatsby");
Book favouriteBook = book;

book.setTitle("The Great Gatsby");
// book.title == "The Great Gatsby"
// favouriteBook.title == "The Great Gatsby"
```

Специальное значение, которое обозначает отсутствие текущего значения у переменной ссылочного типа, называется `null`. Его можно присвоить любой переменной, имеющей ссылочный тип.

Любая ссылочная переменная по умолчанию инициализирована значением `null`. То есть, в результате исполнения следующего кода:

```java
String x;
```

значение переменной `x` будет `null`.

### `java.lang.Object` 

Любая переменная ссылочного типа на вершине иерархии наследования имеет класс `Object`.

> `null` не является объектом ссылочного типа, и как следствие, не наследуется от `Object`. Строго говоря, `null` вообще не является объектом.

Побочным эффектом (предусмотренным дизайном языка) от того, что все объекты наследуются от `Object` является то, что у всех объектов можно вызвать (или переопределить) методы, определённые в `Object`.

Неполный список этих методов:
* `String toString()` – позволяет привести любой объект к строке. По умолчанию реализация этого метода возвращает имя класса и некоторое число, о котором можно думать, как об адресе объекта в памяти. У некоторых классов стандартной библиотеки (например, `ArrayList` или `Map.Entry`) этот метод переопределён для того, чтобы возвращать более информативное строковое представление объекта
* `int hashCode()` – позволяет получить хеш-код объекта. Он используется, например, в `HashMap` для того, чтобы определить, в какую ячейку хеш-таблицы можно положить данный объект
* `boolean equals(Object object)` – позволяет проверить равенство двух объектов

> Контракт между `equals()` и `hashCode()`
>
> Очень важно следить за тем, чтобы при переопределении метода `equals()` в своих объектах, также соответствующим образом переопределять метод `hashCode()`. Но почему? 
>
> На самом деле, ожидается строгое выполнение следующего инварианта: *если метод `a.equals(b)` вернул `true`, то хеш-коды `a.hashCode()` и `b.hashCode()` должны совпадать*.
>
> Реализации некоторых алгоритмов и структур данных (например, `HashMap`) полагаются на выполнение этого инварианта. В противном случае не гарантируется их корректная работа.

#### В чём разница между `a.equals(b)` и `a == b`?

На первый взгляд обе этих конструкции должны выполнять одно и то же: проверку на равенство. Однако, между ними есть большая разница.

`a == b` проверяет равенство ссылок. То есть, указывают ли обе эти переменные на один и тот же объект в памяти. Только в этом случае результат этого выражения равняется `true`, во всех остальных случаях – `false`.

Пример:

```java
Book firstBook = new Book("1984");
Book secondBook = new Book("1984");

firstBook == secondBook // false


Book book = firstBook;

firstBook == book; // true
```

`a.equals(b)`, в свою очередь, проверяет равенство объектов по содержимому. Так, например, этот метод определён для классов стандартной библиотеки, что позволяет, например, проверить равенство двух объектов класса `HashMap` вызовом одного метода!

Также стоит помнить, что дефолтная реализация метода `equals()` в `Object` выглядит следующим образом:

```java
boolean equals(Object other) {
    return this == other;
}
```

То есть, по умолчанию это просто заменяется на проверку равенства ссылок. Об этом важно помнить, создавая собственные классы, так как при наличии полей наверняка равенства ссылок будет недостаточно.

## `boolean`

`boolean` является типом данных для логических значений в Java. Переменные такого типа могут принимать значения `true` или `false`.

Например, все операторы сравнения возвращают значение логического типа в результате их применения.

> Всего в Java есть шесть операторов сравнения: `>`, `>=`, `<`, `<=`, `==`, `!=`

Есть одна особенность, которая сильно отличает Java от, например, C++ и подобных языков, в которых есть эта возможность. В Java нет неявного приведения к логическому типу. То есть, для того, чтобы проверить, равняется ли нулю целочисленная переменная, недостаточно поместить её в условие оператора `if`: обязательно вызвать операцию явного сравнения с нулём.

| Нельзя                          |                   Можно                |
|---------------------------------|----------------------------------------|
| ```java int x = 10; if (x) {}``` | ```java int x = 10; if (x != 0) {} ``` |

Помимо операторов сравнения, в Java также есть ещё несколько операторов, возвращающих `boolean`. Это так называемые логические операции.

| Операция             | Оператор |
|----------------------|:--------:|
| Логическое "и"       |   `&&`   |
| Логическое "или"     | `||`     |
| Исключающее или      | `^`      |
| Логическое отрицание | `!`      |

Для первых трёх операторов существует также их разновидность, совмещённая с оператором присваивания, а именно: `&=`, `|=` и `^=`. Они работают (на примере логического "и") по следующей схеме:

```java
boolean a, b;

a = (boolean)(a && b);
// Снизу – сокращённая запись выражения сверху
a &= b;
```

Объяснение, откуда появился `(boolean)` и что это значит, будет рассмотрено в разделе про [преобразование типов](#Преобразование-типов)

### Вычисление по сокращённой схеме

Существует два варианта операторов логического "и" и "или". Для "и" это `&` и `&&`, а для "или" – `|` и `||`. В чём между ними разница?

Как известно из алгебры логики, выражение, состоящее из цепочки подвыражений, связанных логическим "и", ложно тогда, когда хотя бы одно из подвыражений ложно. В Java тоже есть такая возможность: при использовании операторов вычисления по сокращённой схеме (они состоят из двух символов: `&&` и `||`) в качестве результата выражения сразу вернётся `false` как только одно из подвыражений в цепочке, связанной оператором `&&`, будет вычислено как ложное.

С этим нужно обходиться осторожно. Так, например, при соответствующих условиях не будут вычислены выражения даже имеющие побочные эффекты. Например, если в выражении `foo() && bar() && baz()` функция `foo()` вернёт `false`, а остальные функции при вызове должны были напечатать что-то на экран, на экран не будет выведено ничего.

### `java.lang.Boolean`

У класса-обёртки `Boolean` есть несколько удобных функций.

Например, есть метод `boolean parseBoolean(String)`, который по строке определяет, какой логический литерал кодирует эта строка. Вообще говоря, этот метод возвращает `true` исключительно в том случае, если передпнная на вход строка в точности равна `"true"`.

Также, чтобы избежать лишних выделений памяти, когда в этом нет необходимости, класс `Boolean` предоставляет две статические константы: `Boolean.TRUE` и `Boolean.FALSE`. Так, например, большинство IDE будет выдавать предупреждение, если напрямую вызвать `new Boolean(true)`, потому что можно было бы использовать статическую константу.

## `char`

Представителем символьного типа в языке Java является тип `char`. Переменные такого типа могут хранить символы в кодировке Unicode.

Стоит отметить, что выражение типа `char` можно неявно привести к любому (кроме `byte`, так как у него меньше размер) целочисленному типу.

### Как можно задавать значения типа `char`?

Во-первых, существуют символные литералы. Это символ Unicode, заключённый в одинарные кавычки: `'F'`.

Помимо этого символ можно задавать с помощью его шестнадцатиричного кода (полезно, например, для непечатаемых символов – управляющих последовательностей из начала таблицы ASCII или для специальных символов, с помощью которых можно настроить задать текста в терминале): `'\u263a'`.

Последним способом является задание некоторых спецпоследовательностей, распознаваемых языком. Перечислим их в таблице ниже:

| Последовательность |                      Описание                      |
|--------------------|:--------------------------------------------------:|
| `\t`               |                  Символ табуляции                  |
| `\b`               | Символ backspace: удаление одного символа в строке |
| `\n`               | Символ перехода на новую строку                    |
| `\r`               | Символ возврата каретки                            |
| `\f`               | Символ "смены страницы" (form feed)                |
| `\'`               | Символ одинарной кавычки                           |
| `\"`               | Символ двойной кавычки                             |
| `\\`               | Символ одной обратной косой черты `\`              |

### `java.lang.Character`

У класса `Character` есть несколько статических методов (весьма полезных, например, при посимвольном парсинге данных), которые определяют, к какому классу принадлежит переданный аргументом символ. К таким методам относятся:

* `boolean isLowerCase(char x)`
* `boolean isUpperCase(char x)`
* `boolean isDigit(char x)`
* `boolean isWhiteSpace(char x)`
* `boolean isLetter(char x)`

Помимо этого также есть методы для конвертации символа в верхний и нижний регистр:

* `char toUpperCase(char x)`
* `char toLowerCase(char x)`

Ещё можно отметить наличие методов `int digit(char ch, int radix)` и обратного к нему `char forDigit(int digit, int radix)`. Они позволяют получить число, которому соответствует символ в указанной системе счисления и наоборот: по числу и системе счисления позволяет вернуть символ, которым это число будет кодироваться.

Это далеко не полный список методов этого класса, всего у него в публичном интерфейсе порядка 90 методов и много разных статических констант.

## Целочисленные типы

Серьёзным отличием от C++ является то, что размер всех целочисленных типов зафиксирован стандартом и не зависит от конкретной реализации JVM. Конкретные размеры типов данных приведены в таблице в начале главы.

### Как можно задавать значения целочисленных типов?

Для этого существует несколько различных вариантов. Самый простой – задать число в его десятичном представлении. Однако, числовые литералы можно представлять и в других системах счисления!

Чтобы задать числовой литерал в восьмеричной системе счисления, необходимо в качестве первого символа указать `0` (например: `int x = 016` задаст число 14, записанное в восьмеричной системе счисления).

Чтобы задать в шестнадцатиричной системе счисления – нужно указать префикс `0x` (например: `int x = 0xf1` задаст число 241, записанное в шестнадцатиричной системе счисления).

Начиная с Java 7, появился ещё один вариант записи целочисленных литералов. Теперь число можно задать и в двоичной системе счисления, для чего указывается префикс `0b` (например: `int x = 0b110` задаст число 6, записанное в довичной системе счисления).

Помимо представления в разных системах счисления, существуют ещё некоторые способы записи целочисленных литералов. Так, для того, чтобы задать литерал типа `long`, необходимо добавить суффикс `L` к записи числа (в любой из перечисленных выше систем счисления). Так, например, можно уберечь себя от ошибки, когда по неосторожности присваивается литерал, имеющий тип `long` в переменную типа `int`.

> Начиная с Java 7, в записи числа допустимы нижние подчёркивания. Этим можно пользоваться, например, для визуальной группировки разрадов числа, что значительно упрощает его чтение человеком. Сравните, насколько быстро получится понять порядок следующих двух чисел: `long x = 1000000000;` и `long y = 1_000_000_000;`.

### Арифметические операции

Все целочисленные типы поддерживают стандартный набор арифметических операций: сложение, вычитание, умножение, деление и взятие остатка от деления. Для каждой из этих операций существует соответствующий арифметический оператор, а также оператор, совмещённый с присваиванием.

Помимо них переменные целочисленного типа данных поддерживают операцию (как префиксного, так и постфиксного) инкремента и декремента (`++` и `--`).

При делении **целого числа** на ноль, бросается исключение `ArithmeticException`. (Акцент на следующем: для чисел с плавающей точкой деление на ноль имеет другое поведение, которое не приводит к возникновению исключения)

Переполнение (в отличие от C++) не является неопределённым поведением. При переполнении просто отбрасываются старшие биты получившегося числа. Для сравнения в C++ такое поведение гарантируется для беззнаковых чисел, а для чисел со знаком оно не определено.

### Классы-обёртки

Из примечательного в классах-обёртках можно выделить наличие статических полей, содержащих минимальное и максимальное возможное значение соответствующего типа. Например, `java.lang.Integer.MAX_VALUE` и `java.lang.Integer.MIN_VALUE`.

Также в них есть методы для безопасной конвертации значений в числа с плавающей точкой (`double doubleValue()`), парсинга числа из строки (`int parseInteger(String s, int radix)`) и многие другие.

> **А что с беззнаковыми числами?**
>
> До Java 8 их просто не было. Совсем 🙂.
>
> С Java 8 был расширен интерфейс классов-обёрток над целочисленными типами: туда добавили операции, которые позволяют работать с содержимым класса как с беззнаковым целым числом. К числу таких методов, например, относится `int divideUnsigned(int a, int b)`, который интерпретирует числа `a` и `b` как беззнаковые целые, и вернёт резальтат деления `a` на `b`.

## Типы данных для чисел с плавающей точкой

Чтобы задать такое число, можно с помощью точки показать, в каком месте заканчивается целая часть числа и начинается дробная. Помимо этого существует также экспоненциальная запись числа (ещё называемая *scientific notation*): `314.15e-2` означает `314.15 * 10^{-2}`.

Вещественные числа также можно записывать и в шестнадцатиричной системе счисления (однако, только в экспоненциальной записи). Для этого у  числа указывается `0x` в качестве префикса, а экспонена обозначается символом `p`: `0xDEADpBE` означает `DEAD * 2^BE`.

Для вещественных литералов также есть суффиксы, обозначающие принадлежность к конкретному типу данных: `f` для `float` и `d` для `double`. 

По умолчанию все вещественные литералы имеют тип `double`. Не знание этого факта может привести к непониманию, почему компилятор Java отказывается компилировать следующий код: `float x = 2.0;`.

### Деление на 0 и прочие особые случаи

В отличие от целых чисел, деление на 0 вещественного числа не приводит к возникновению ошибки. Для вещественных чисел определены специальные значения: бесконечность (`Double.POSITIVE_INFINITY`) и NaN (`Double.NaN`).

Как подсказывает название, бесконечность может иметь положительный или отрицательный знак. Собственно, результатом деления на ноль является бесконечность с таким же знаком, как у делимого.

Переполнение при операциях с плавающей точкой также возвращает бесконечность в качестве результата операции.

При делении нуля на ноль возвращается NaN, так как в математике результат такой операции не определён.

> При любой операции с NaN результатом является NaN. Такое явление называется *NaN-propagation*.
>
> Это довольно просто объяснить, если посмотреть, как устроено значение NaN в памяти. По стандарту IEEE-754 (ему соответствуют типы `float` и `double` в Java) NaN представляется как число, у которое все биты порядка равны единице, а биты мантиссы равны чему угодно, кроме нуля одновременно (потому что таким образом представляется бесконечность). 
>
> Тогда действительно не сложно представить, что все операции, которые не изменят порядок, приведут к тому, что в результате этой операции снова получится NaN. Если же операция меняет порядок.. то так как нельзя с уверенностью сказать, какое число участвовало в операции на месте NaN, можно заменить порядок результата операции на все единичные биты и гарантировать, что в результате этой операции не вернулось какое-то "мусорное" число.

## Преобразование типов

Его принято делить на два случая: явное и неявное преобразование. Дизайн языка Java предполагает сведение к минимуму неявных преобразований (о чём, например, говорит отсутствие неявного преобразования в `boolean`).

### Неявные преобразования

С примером неявного преобразования мы сталкивались выше, обсуждая символьный тип данных [char](#char). Там говорилось о том, что он может приводитсья к любому целочисленному типу с большим или равным размером.

Это же справедливо и для всех остальных целочисленных типов данных. Такой тип преобразования называется *widening conversion*.

Помимо этого также существует преобразование целочисленных типов в типы с плавающей точкой. Однако, здесь стоит быть внимательным, так как такое преобразование может сопровождаться потерей точности (например, целое число `16777217` не представимо без потери точности во `float`, несмотря на то, что при этом можно точно прдеставить как `16777216`, так и `16777218`).

#### Автоматическое расширение

Особый случай неявного приведения типов происходит при операциях с несколькими выражениями различных типов данных. Идея компилятора Java заключается в том, что все операнды в выражении нужно привести к какому-то общему типу. Это будет что-то вроде наименьшего из достаточно широких типов, чтобы в нём можно было с минимальными потерями точности выразить каждый из операндов.

Поэтому в таких случаях применяются следующие правила:

* Если одно из выражений имеет тип `double`, общий тип выводится как `double` (никакие другие типы не могут представить любое число из `double` без серьёзных потерб точности. И наоборот: любой численный тип представим в `double` с незначительной потерей точности)
* или если одно из выражений имеет тип `float`, тип выводится во `float`
* или если одно из выражений – `long`, выводится `long`
* или если одно из выражений – `int`, выводится `int`.

> Стоит обратить внимание, что на этом правила заканчиваются. Рассмотрим следующий код:
>
> ```java
> char x = 'a';
> char y = 'a';
> char z = x + y;
> ```
>
> Он приводит к ошибке компиляции! Чтобы её избежать, достаточно явно использовать оператор приведения типов обратно к `char`.

### Явные преобразования

Для явного приведения типов существуют соответствующие операторы. Если преобразование допустимо, то для того, чтобы его совершить, необходимо в скобках перед выражением указать тип данных, к которому необходимо привести выражение. Например `(int)(10.0 - 5.8)`.

* Если целочисленный тип, к которому осуществляется приведение, имеет меньшую разменрость, то старшие биты результата выражения отбрасываются;
* При приведении вещественного типа к целому отбрасывается дробная часть;
* Если при этом вещественное число имело слишком большое значение, то в результате приведения к целому типу будет возвращено `MIN_VALUE` или `MAX_VALUE`;
* В свою очередь, при приведении слишком большого `double` к `float` результатом выражения будет бесконенчость с соответствующим знаком.

> "Неявное явное преобразование"
>
> При использовании оператора, совмещённого с присваиванием, компилятор неявно подставляет оператор явного приведения типа перед получившимся выражением. Почему?
> 
> Потому что в такой записи пользователь может взаимодействовать только с правым операндом получившегося выражения в то время, как несовместимый тип может получиться после применения оператора. Поэтому, чтобы не создавать безвыходных ситуаций, компилятор подставляет в итоговое выражение оператор приведения типа.
>
> Стоит отметить, что такое поведение приведёт к приведению типа, даже если это будет сопровождаться потерей точности. Пример:
>
> ```java
> int x = 40;
> x += 2.0; // В то время, как прямое присваивание x = 42.0 не скомпилируется из-за несоответствия типов
> ```

## Boxing и unboxing

Примитивные типы могут свободно неявно преобразовываться в соответствующие типы-обёртки и обратно. Процесс преобразования примитивного типа в тип-обёртку называется *boxing*, а обратный процесс – *unboxing*.

### `Integer` pool

В целях оптимизации (очень похожим образом, как это сделано в Python) в JVM существует так называемый пул `Integer`-ов. В нём находятся заранее созданные 256 объектов типа `Integer` на каждое число из диапазона `[-128, 127]`.

Таким образом, при **неявном** приведении чисел из этого диапазона к `Integer` не будет по-настоящему создаваться новых объектов, а вместо этого переменные будут получать ссылки на объекты из пула.

К чему это приводит? К неожиданному на первый взгляд поведению. Так объекты, полученные таким образм, будут равны в том числе с точностью до `==` (то есть, будут хранить одинаковые ссылки), в то время как для остальных объектов классов-обёрток это свойство не выполняется.

## Передача аргументов в методы

На самом деле, правила при этом не отличаются от правил при присваивании: примитивные типы копируются, а объекты – передаются по ссылке. На этом акцентировалось внимание, когда говорилось про отличия примитивных типов от ссылочных.

Однако, есть интересный пример, на который хотелось бы взглянуть:

```java
class Example {
    public static void foo(Integer x) {
        x = 3;
    }

    public static void main(String[] args) {
        Integer x = 1;
        foo(x);
        System.out.println(x); // 1
    }
}
```

Почему так происходит? На первый взгляд кажется, что раз функция принимает ссылочный тип, то его содержимое должно измениться снаружи.

Однако, если посмотреть внимательнее, то можно заметить следующее: в выражении `x = 3;` происходит boxing. То есть, число `3` преобразуется в объект типа `Integer`, на который уже будет совершенно другая ссылка. Предыдущий объект по этой ссылке не изменяется, что и приводит к наблюдаемому результату.
