# Примитивные и ссылочные типы в Java

## Примитивные типы

Рассмотрим таблицу, в которой перечислены все примитивные типы в Java:

| Тип       | Размер (байт) |
|-----------|:-------------:|
| `void`    |       0       |
| `boolean` |     1 бит     |
| `char`    |       2       |
| `byte`    |       1       |
| `short`   |       2       |
| `int`     |       4       |
| `long`    |       8       |
| `float`    |       4       |
| `double`  |       8       |

Особенности:

* Как `boolean` занимает 1 бит? Идея в том, что 8 разных переменных типа `boolean` могут храниться в одной 8-битной ячейке памяти, тем самым занимая по 1 биту каждая. Стоит отметить, что это зависит от реализации JVM. Есть JVM, в которых `boolean` занимает столько же, сколько и `int`. В спецификации языка Java это единственный примитивный тип, для которого не определён строгий размер.

Примитивные типы можно разделить на целочисленные, нецелочисленные, символьный тип `char`, логический тип `boolean` и пустой тип `void`.

> Примитивные типы передаются по значению. Что это значит?
>
> Это значит, что выражение `x = y`, где `x` и `y` имеют какой-нибудь примитивный тип (для определённости пусть это будет `int`) приведёт к тому, что значение переменной `y` будет скопировано в переменную `x`.
>
> Если после этого, например, вызвать оператор инкремента у переменной `x`: `x++`, то значение `y` останется прежним, так как оно было скопировано.
>
> Пример:
> ```java
> int x = 4;
> int y = 2;
> x = y;
> x++;
> // x == 3, y == 2
> ```

## Ссылочные типы

В противопоставление примитивным типам в Java также имеются ссылочные типы. Все остальные типы, кроме перечисленных выше являются ссылочными.

> Часто говорят, что "ссылка" сама по себе является особым примитивным типом. 
>
>Действительно, если рассматривать любую переменную ссылочного типа как переменную, хранящую некий адрес в памяти, с которым особенным образом умеет обращаться Java, то такая переменная – которая просто хранит целое число – будет являться переменной примтивного типа.

Передача значения по ссылке позволяет двум переменным указывать на один и тот же объект. Это значит, что изменение этого объекта в одной переменной приведёт к его изменению в другой переменной.

Пример:
```java
Book book = new Book("The Gold-Hatted Gatsby");
Book favouriteBook = book;

book.setTitle("The Great Gatsby");
// book.title == "The Great Gatsby"
// favouriteBook.title == "The Great Gatsby"
```

Специальное значение, которое обозначает отсутствие текущего значения у переменной ссылочного типа, называется `null`. Его можно присвоить любой переменной, имеющей ссылочный тип.

Любая ссылочная переменная по умолчанию инициализирована значением `null`. То есть, в результате исполнения следующего кода:

```java
String x;
```

значение переменной `x` будет `null`.

### `java.lang.Object` 

Любая переменная ссылочного типа на вершине иерархии наследования имеет класс `Object`.

> `null` не является объектом ссылочного типа, и как следствие, не наследуется от `Object`. Строго говоря, `null` вообще не является объектом.

Побочным эффектом (предусмотренным дизайном языка) от того, что все объекты наследуются от `Object` является то, что у всех объектов можно вызвать (или переопределить) методы, определённые в `Object`.

Неполный список этих методов:
* `String toString()` – позволяет привести любой объект к строке. По умолчанию реализация этого метода возвращает имя класса и некоторое число, о котором можно думать, как об адресе объекта в памяти. У некоторых классов стандартной библиотеки (например, `ArrayList` или `Map.Entry`) этот метод переопределён для того, чтобы возвращать более информативное строковое представление объекта
* `int hashCode()` – позволяет получить хеш-код объекта. Он используется, например, в `HashMap` для того, чтобы определить, в какую ячейку хеш-таблицы можно положить данный объект
* `boolean equals(Object object)` – позволяет проверить равенство двух объектов

> Контракт между `equals()` и `hashCode()`
>
> Очень важно следить за тем, чтобы при переопределении метода `equals()` в своих объектах, также соответствующим образом переопределять метод `hashCode()`. Но почему? 
>
> На самом деле, ожидается строгое выполнение следующего инварианта: *если метод `a.equals(b)` вернул `true`, то хеш-коды `a.hashCode()` и `b.hashCode()` должны совпадать*.
>
> Реализации некоторых алгоритмов и структур данных (например, `HashMap`) полагаются на выполнение этого инварианта. В противном случае не гарантируется их корректная работа.

#### В чём разница между `a.equals(b)` и `a == b`?

На первый взгляд обе этих конструкции должны выполнять одно и то же: проверку на равенство. Однако, между ними есть большая разница.

`a == b` проверяет равенство ссылок. То есть, указывают ли обе эти переменные на один и тот же объект в памяти. Только в этом случае результат этого выражения равняется `true`, во всех остальных случаях – `false`.

Пример:

```java
Book firstBook = new Book("1984");
Book secondBook = new Book("1984");

firstBook == secondBook // false


Book book = firstBook;

firstBook == book; // true
```

`a.equals(b)`, в свою очередь, проверяет равенство объектов по содержимому. Так, например, этот метод определён для классов стандартной библиотеки, что позволяет, например, проверить равенство двух объектов класса `HashMap` вызовом одного метода!

Также стоит помнить, что дефолтная реализация метода `equals()` в `Object` выглядит следующим образом:

```java
boolean equals(Object other) {
    return this == other;
}
```

То есть, по умолчанию это просто заменяется на проверку равенства ссылок. Об этом важно помнить, создавая собственные классы, так как при наличии полей наверняка равенства ссылок будет недостаточно.